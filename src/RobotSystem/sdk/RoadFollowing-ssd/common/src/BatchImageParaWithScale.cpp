#include "BatchImageParaWithScale.h"

// The new version of serialize function
void GetEvbImageInfoSearPtr(void* input_ptr, std::string& ctrl_str, uint8_t*& data_ptr,
                            uint32_t& data_len) {
    if (input_ptr == nullptr) {
        return;
    }
    EvbImageInfo* image_info = reinterpret_cast<EvbImageInfo*>(input_ptr);
    ctrl_str = std::string(reinterpret_cast<char*>(input_ptr), sizeof(EvbImageInfo));
    data_ptr = reinterpret_cast<uint8_t*>(image_info->pucImageData);
    data_len = image_info->size;
}

bool isSentinelImage(const std::shared_ptr<BatchImageParaWithScaleT> image_handle) {
    if (image_handle && image_handle->b_info.batch_ID == -1) {
        return true;
    }
    return false;
}

// The new version of deserialize function
std::shared_ptr<void> GetEvbImageInfoDearPtr(const char* ctrl_ptr, const uint32_t& ctr_len,
                                             const uint8_t* data_ptr, const uint32_t& data_len) {
    if (ctrl_ptr == nullptr) {
        return NULL;
    }
    EvbImageInfo* image_info =
        const_cast<EvbImageInfo*>(reinterpret_cast<const EvbImageInfo*>(ctrl_ptr));
    std::shared_ptr<BatchImageParaWithScaleT> image_handle =
        std::make_shared<BatchImageParaWithScaleT>();
    image_handle->b_info.frame_ID.push_back(image_info->frame_ID);
    image_handle->b_info.batch_size = image_info->batch_size;
    image_handle->b_info.max_batch_size = image_info->max_batch_size;
    image_handle->b_info.batch_ID = image_info->batch_ID;
    image_handle->b_info.is_first = image_info->is_first;
    image_handle->b_info.is_last = image_info->is_last;
    if (isSentinelImage(image_handle)) {
        return image_handle;
    }
    NewImageParaT imgData;
    imgData.img.format = (IMAGEFORMAT)image_info->format;
    imgData.img.width = image_info->width;
    imgData.img.height = image_info->height;
    imgData.img.size = image_info->size;  // Get image info size;
    imgData.img.data.reset(const_cast<uint8_t*>(data_ptr), hiai::Graph::ReleaseDataBuffer);
    image_handle->v_img.push_back(imgData);
    return std::static_pointer_cast<void>(image_handle);
}

/**
* @brief: get the result file name from the image name
* @[in]: imgFullPath: the image file path
* @[in]: postfix: the type of the result file
*/
std::string GenTfileName(std::string imgFullPath, std::string postfix) {
    std::size_t name_cnt = imgFullPath.find_last_of(".");
    std::size_t found = imgFullPath.find_last_of("/\\");
    std::string tfileName =
        "davinci_" + imgFullPath.substr(found + 1, name_cnt - found - 1) + postfix;
    return tfileName;
}

/**
* @brief: get the image information from the info_file generated by dataset
* engine
* @[in]: info_file: the info file path
* @[in]: postfix: the type of the result file
*/
std::unordered_map<int, ImageInfor> SetImgPredictionCorrelation(std::string info_file,
                                                                std::string postfix) {
    std::ifstream fin(info_file.c_str());
    if (!fin) {
        HIAI_ENGINE_LOG(HIAI_IDE_ERROR, "fail to open info file.");
    }
    std::unordered_map<int, ImageInfor> result;
    std::string line_content;

    std::getline(fin, line_content);
    std::string datasetName;
    int totalFileNum = 0;
    std::stringstream lineStr1(line_content);
    lineStr1 >> datasetName >> totalFileNum;

    int format = -2;
    int fileNumByFormat = 0;
    int count = 0;
    while (count < totalFileNum) {
        std::getline(fin, line_content);
        std::stringstream lineStrFormat0(line_content);
        lineStrFormat0 >> format >> fileNumByFormat;
        count += fileNumByFormat;
        for (int ind = 0; ind < fileNumByFormat; ind++) {
            std::getline(fin, line_content);
            int frame_id;
            std::string img_fullpath;
            int width, height;
            std::stringstream lineStr(line_content);
            lineStr >> frame_id >> img_fullpath >> width >> height;
            ImageInfor img_infor;
            img_infor.tfilename = GenTfileName(img_fullpath, postfix);
            img_infor.height = height;
            img_infor.width = width;
            img_infor.format = format;
            result[frame_id] = img_infor;
        }
    }
    return result;
}

/**
* @brief: get the caffe layer name and index
* @[in]: in_name: the name of tensor
* @[in]: index: the index of output tensor
* @[in]: out_name: the caffe layer name
*/
void GetLayerName(const std::string in_name, std::string& index, std::string& out_name) {
    auto pos = in_name.find_last_of("_");
    index = in_name.substr(pos + 1);
    out_name = in_name.substr(0, pos);
    for (int num_underline = 2; num_underline > 0; num_underline--) {
        auto pos_underline = out_name.find_first_of("_");
        out_name = out_name.substr(pos_underline + 1);
    }
}

/**
* @brief: create folder to store the detection results
* the folder name on the host will be "result_files/enginename"
*/
HIAI_StatusT CreateFolder(std::string folderPath, mode_t mode) {
    int folder_exist = access(folderPath.c_str(), W_OK);
    if (-1 == folder_exist) {
        if (mkdir(folderPath.c_str(), mode) == -1) {
            HIAI_ENGINE_LOG(HIAI_IDE_ERROR, "Create %s failed !", folderPath.c_str());
            return HIAI_ERROR;
        }
    }
    return HIAI_OK;
}

/**
* @brief: get the information file path in the dataset folder
* @[in]: value, path configuration string
* @[return]: string, info file path
*/
std::string GetInfoFilePath(const std::string pathConfig) {
    std::string datainfo_path = pathConfig;
    while (datainfo_path.back() == '/' || datainfo_path.back() == '\\') {
        datainfo_path.pop_back();
    }
    std::size_t tmp_ind = datainfo_path.find_last_of("/\\");
    std::string info_file_ =
        datainfo_path + "/" + "." + datainfo_path.substr(tmp_ind + 1) + "_data.info";
    HIAI_ENGINE_LOG(HIAI_IDE_INFO, "info file:%s", info_file_.c_str());
    return info_file_;
}
